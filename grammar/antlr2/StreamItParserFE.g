/* This file is simplified from the grammar file in sketch-frontend
 * repo, removing all dependencies and all keeping the grammar structure.
 * ref: https://github.com/asolarlez/sketch-frontend/blob/master/src/main/other/sketch/compiler/parser/StreamItParserFE.g
 */
/*
 * Copyright 2003 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/*
 * StreamItParserFE.g: Sketch parser producing front-end tree
 * $Id: StreamItParserFE.g,v 1.41 2008/03/22 02:17:05 cgjones Exp $
 */

options {
    // NOTE -- increase lookahead depth to support previously
    // ambiguous expressions like expr_named_param
    k = 2;
    importVocab=StreamItLex;	// use vocab generated by lexer
}

program:	
    (  (annotation_list (/*TK_device  | TK_global |*/  TK_serial | TK_harness |
                     TK_generator |  TK_stencil | TK_model)*
                    return_type ID  (type_params)? LPAREN) => function_decl 
           |    (return_type ID (type_params)? LPAREN) => function_decl  
           | 	field_decl SEMI 
           |    (annotation_list TK_struct) => struct_decl
           |    adt_decl
           |    special_assert_statement 
           |    include_stmt
           |    TK_package ID 
                            (SEMI  | pkgbody) 
           |    pragma_stmt
        )*
        EOF
    ;


pkgbody: 
    LCURLY
  (  (annotation_list (/*TK_device  | TK_global |*/  TK_serial | TK_harness |
                     TK_generator |  TK_stencil | TK_model)*
                    return_type ID (type_params)? LPAREN) => function_decl
           |    (return_type ID (type_params)? LPAREN) => function_decl
           | 	field_decl SEMI
           |    (annotation_list TK_struct) => struct_decl
           |    adt_decl
           |    special_assert_statement
   )*
   RCURLY
   ;

include_stmt
    :   TK_include STRING_LITERAL SEMI
    ;

pragma_stmt:
    TK_pragma ID
        ( STRING_LITERAL)?
        SEMI
    ;

field_decl:
    data_type ID (ASSIGN expr_or_lambda)?
        (
            COMMA ID (ASSIGN expr_or_lambda)?
        )*
    ;

statement:
        loop_statement //1
    |   minrepeat_statement
    |   fork_statement
    |   spmdfork_statement
    |   parfor_statement // 5
    |	insert_block
    |	reorder_block
    |	atomic_block
    |	(LCURLY)=> block // 9
    |   (return_type ID LPAREN) => fdecl_statement
    |	(data_type ID) => variable_decl SEMI!
    |	(expr_statement) => expr_statement SEMI!
    |	TK_break SEMI
    |	TK_continue SEMI
    //ADT
    |	switch_statement
    |	if_else_statement
    |	while_statement
    |	do_while_statement SEMI
    |	for_statement
    |	assume_statement SEMI
    |	assert_statement SEMI
    |	assert_max_statement SEMI
    |   hassert_statement SEMI
    |   (annotation_list (TK_device | TK_serial | TK_harness |
                     TK_generator | TK_library | TK_printfcn | TK_stencil | TK_model)*
                    return_type ID LPAREN) => fdecl_statement  
    |   return_statement SEMI
    |   SEMI
    ;

fdecl_statement: function_decl;
    
loop_statement:
    ((TK_loop | TK_repeat) LPAREN ID COLON) => 
    (TK_loop | TK_repeat) LPAREN ID COLON right_expr RPAREN pseudo_block
    | (TK_loop | TK_repeat) LPAREN right_expr RPAREN pseudo_block;

minrepeat_statement 
    : (TK_minrepeat) pseudo_block
    ;

fork_statement  
    : TK_fork LPAREN variable_decl SEMI right_expr RPAREN pseudo_block
    ;

spmdfork_statement  
    : TK_spmdfork LPAREN (ID  SEMI)? right_expr RPAREN pseudo_block
    ;

parfor_statement  
    : TK_parfor LPAREN var_expr LARROW range_exp RPAREN pseudo_block
    ;

range_exp  
    : right_expr TK_until right_expr (TK_by right_expr)? 
    ;

type_params_use:
(LESS_THAN 
(ID AT)? ID
LESS_THAN
data_type
RSHIFT
) => 
LESS_THAN 
(ID AT)? ID 
LESS_THAN
data_type
RSHIFT 
|
LESS_THAN data_type  
          (COMMA data_type  )*  
MORE_THAN
;

data_type  
    :	 (TK_global )? 
                (primitive_type 
                | (ID AT)? ID 
                | BITWISE_OR (ID AT)? ID BITWISE_OR )
        (  type_params_use)?
        (	LSQUARE
            (	
                ( 
                (expr_named_param
                    (
                    LESS_COLON NUMBER 
                    )?
                )
                | )
                ( 
                COMMA expr_named_param  
                    (
                    LESS_COLON NUMBER 
                    )?
                )*
            )
            RSQUARE
        )*
    |	TK_void 
    ;

primitive_type  
    :
        (TK_boolean 
    |	TK_bit 
    |	TK_int 
    |	TK_float 
    |	TK_double 
    |   TK_fun 
    |	TK_char )
    ;

variable_decl  
    :	data_type
        ID
        (ASSIGN expr_or_lambda)?
        (
            COMMA ID (ASSIGN expr_or_lambda)?
        )*
    ;


expr_or_lambda  
:
   (LPAREN (RPAREN | ID (RPAREN ARROW | COMMA)   )  ) =>  lambda_expr
   | right_expr
;

annotation : AT ID LPAREN (STRING_LITERAL)? RPAREN
;

annotation_list  
    :	
        ( annotation )*
    ;

type_params   
:
LESS_THAN ID  (COMMA ID  )* MORE_THAN ;

function_decl  
    :
    annotation_list
    ( 
          TK_serial  |
          TK_harness  |
          TK_generator   |      
          TK_stencil  | 
          TK_model 
        )*
    return_type
    ID
    (type_params)?
    param_decl_list 
    (TK_implements ID)?
    (TK_fixes  ( ID ) )?
    ( block
    | SEMI  )
    ;

return_type  
    : 	data_type
    ;

param_decl_list  
    :	LPAREN
        (impl_param )?
        (param_decl  (COMMA param_decl )*
        )?
        RPAREN
    ;

impl_param 
    : LSQUARE TK_int ID 
      (COMMA TK_int ID )* 
      RSQUARE COMMA
    ;
param_decl  
    : 	(TK_ref  )?	 data_type ID 
    ;

block  
    :	LCURLY ( statement  )* RCURLY
    ;

insert_block 
    :	TK_insert LCURLY ( statement  )* RCURLY
        TK_into   LCURLY ( statement  )* RCURLY
    ;


reorder_block  
    :	TK_reorder LCURLY ( statement  )* RCURLY
    ;

atomic_block  
    :   TK_atomic (LPAREN right_expr RPAREN)? block
    ;

pseudo_block  
    :	 statement 
    ;

return_statement  
    :	TK_return (right_expr)? 
    ;

assume_statement  
    :   (TK_assume)  right_expr (COLON STRING_LITERAL)? 
    ;

special_assert_statement  
    : (( TK_let) ((ID ASSIGN  right_expr)  (COMMA ID ASSIGN  right_expr )* )?
      ) LCURLY
      (( TK_assume)  right_expr)?
      (( TK_assert)  right_expr SEMI )
      (( TK_assert)  right_expr SEMI )* 
        RCURLY
    | (( TK_assert)  right_expr SEMI )
    ;
    
assert_statement  
    :	(TK_assert | TK_h_assert) right_expr (COLON STRING_LITERAL)?	
    ;

hassert_statement  
    :	(TK_hassert) right_expr (COLON STRING_LITERAL)?
    ;
    
assert_max_statement  
:	TK_assert_max ( BACKSLASH)? right_expr (COLON STRING_LITERAL)? 
;
//ADT
switch_statement 
    :	TK_switch LPAREN ID RPAREN LCURLY
        (TK_case ID COLON  pseudo_block
        )*
        ((TK_default COLON  pseudo_block
        )
        |
        (TK_repeat_case COLON  pseudo_block
        ))?
        RCURLY
    ;

if_else_statement 
    :	TK_if LPAREN right_expr RPAREN pseudo_block
        ((TK_else) => (TK_else pseudo_block))?
    ;

while_statement  
    :	TK_while LPAREN right_expr RPAREN pseudo_block
    ;

do_while_statement 
    :	TK_do pseudo_block TK_while LPAREN right_expr RPAREN
    ;

for_statement 
    :	TK_for LPAREN for_init_statement SEMI
        (right_expr | )
        SEMI for_incr_statement RPAREN pseudo_block
    ;

for_init_statement  
    :	(variable_decl) => variable_decl
    |	(expr_statement) => expr_statement
    |   /* empty */ 
    ;

for_incr_statement  
    :	expr_statement
    |   /* empty */ 
    ;

expr_statement  
    :	 assign_expr
    ;

assign_expr  
    :	prefix_expr
        ( (
            (	ASSIGN 
            |	PLUS_EQUALS 
            |	MINUS_EQUALS 
            |	STAR_EQUALS 
            |	DIV_EQUALS 
            |   DOTASSIGN 
            )
            expr_or_lambda
          )
            | 
        )
    ;

func_call  
    : ID (AT ID)? func_call_params
    ;

expr_get  
    : NDVAL2 LPAREN LCURLY  expr_get_params RCURLY RPAREN
    ;
    
expr_get_params  
    :	
        (	expr_named_param 
            (COMMA expr_named_param )*
        )?
    ;
    
func_call_params  
    :	LPAREN
        (	expr_named_param 
            (COMMA expr_named_param )*
        )?
        RPAREN
    ;

// (,x, y) -> x + y; 	
lambda_expr   
    : // Left parenthesis 
      LPAREN 
        // A group that occurs 0 or 1 times
        (
            ID 
            // Group that occurs 0 or more times
            (
              COMMA
              // Match an ID and set temp to it
              ID 
            )*
        )?
      // Right parenthesis
      RPAREN
      // ->
      ARROW
      // Operation is any expression
       right_expr
    ;
    
constr_params  
    :	LPAREN
        (	expr_named_param_only 
            (COMMA expr_named_param )*
        )?
        RPAREN
    ;

expr_named_param  
    :   (ID ASSIGN)? 
         expr_or_lambda
    ;

expr_named_param_only  
    :   ID ASSIGN right_expr 
    ;

right_expr_not_agmax  
    :	ternaryExpr	
    ;
right_expr  
    :	right_expr_not_agmax
    ;

arr_initializer  
    : LCURLY
      ( right_expr 
            (COMMA right_expr )*
      )?
      RCURLY
    ;

ternaryExpr  
    :	logicOrExpr
        (QUESTION ternaryExpr COLON ternaryExpr
        )?
    ;

logicOrExpr  
    :	logicAndExpr
        (LOGIC_OR logicAndExpr
        )*
    ;

logicAndExpr  
    :	bitwiseOrExpr
        (LOGIC_AND bitwiseOrExpr
        )*
    ;

bitwiseOrExpr  
    :	bitwiseXorExpr
        (	BITWISE_OR  bitwiseXorExpr
        )*
    ;

bitwiseXorExpr  
    :   bitwiseAndExpr
        (   BITWISE_XOR  bitwiseAndExpr
        )*
    ;

bitwiseAndExpr  
    :   equalExpr
        (   BITWISE_AND  equalExpr
        )*
    ;

equalExpr  
    :	compareExpr 
        (	( EQUAL     
            | TRIPLE_EQUAL 
            | NOT_EQUAL 
            )
             compareExpr
        )*
    ;

compareExpr  
    :	shiftExpr
        (	( LESS_THAN  
            | LESS_EQUAL 
            | MORE_THAN  
            | MORE_EQUAL 
            | DOTLT 
            | DOTGT 
            | DOTLTE 
            | DOTGTE 
            )
             shiftExpr
        )*
    ;

shiftExpr  
    :   addExpr
        (   ( LSHIFT 
            | RSHIFT 
            )
            addExpr
        )*
    ;

addExpr  
    :	multExpr
        (	( PLUS  
            | MINUS 
            | SELECT 
            | DOTPLUS 
            | DOTMINUS 
            )
            multExpr
        )*
    ;

multExpr  
    :	prefix_expr
        (	( STAR 
            | DIV  
            | MOD  
            | DOTTIMES 
            | DOTDIV 
            | DOTMOD 
            )
            prefix_expr
        )*
    ;
    
prefix_expr  
    :
    (castExpr) =>  castExpr
    |  postfix_expr
    | (	  INCREMENT
        |  DECREMENT
        |  BANG  
        |  MINUS  
        )  prefix_expr 	
    ;

prefix_expr_nominus  
    : 
    (castExpr) =>  castExpr
    |	 postfix_expr
    | (	  INCREMENT
        |  DECREMENT
        |  BANG   
        )  prefix_expr 	
    ;
    
castExpr  
    :   LPAREN data_type
        RPAREN
        prefix_expr_nominus
    ;

postfix_expr  
    :  primary_expr 
       ( INCREMENT
        |  DECREMENT)*
    ;
primary_expr  
    :	tminic_value_expr
        (	DOT  ( ID | NDVAL2  | LCURLY  data_type   RCURLY)
        |	LSQUARE
                    array_range 
            RSQUARE
        )*
    ;

tminic_value_expr  
    :	LPAREN right_expr RPAREN
    |   (expr_get) =>  expr_get
    |	(func_call) => func_call
    | 	(constructor_expr) =>  constructor_expr	
    |	var_expr
    |	constantExpr
    |   arr_initializer
    |   REGEN
    ;

constructor_expr
    : TK_new
    (ID AT)? (ID  | NDVAL2)
    (  type_params_use )?
    constr_params 
    | BITWISE_OR 
    (ID AT)? ID 
      BITWISE_OR constr_params 
    ;

var_expr  
:	ID 
    ;
    
array_range  
    : expr_named_param 
        ( COMMA expr_named_param  )*
        (COLON
          ( right_expr 
            | COLON
            right_expr 
          )
        )?
    ;

constantExpr  
    :	HQUAN
    | 	NUMBER
    |	CHAR_LITERAL
    |	STRING_LITERAL
    |	TK_true
    |	TK_false
    |   TK_null
    |   NDVAL
    |   NDVAL2 (LPAREN addExpr (COMMA addExpr)? RPAREN)?
    |	NDANGELIC
    | 	NDVAL2SP
    |  (local_variable) =>  local_variable
    ;
    
local_variable  
    : 	DOLLAR // $ 
        LPAREN 
         data_type 
        RPAREN
     ;

adt_decl 
    :  TK_adt ID 
    (
        LESS_THAN
           ID 
          (COMMA  ID )*
        MORE_THAN		
        )?
        LCURLY
    (adt_decl 
    | structInsideADT_decl 
    | param_decl SEMI 
    | annotation 
    )*
    RCURLY
    ;

structInsideADT_decl 
    :	ID
        LCURLY
        (param_decl SEMI
            | annotation
        )*
        RCURLY
    ;

struct_decl 
    :	(annotation)*
    TK_struct ID 
        (
        LESS_THAN
           ID 
          (COMMA  ID )*
        MORE_THAN		
        )?
        //ADT
        (TK_extends ID 
        )?
        LCURLY
        (param_decl SEMI
            |annotation
        )*
        RCURLY
    ;