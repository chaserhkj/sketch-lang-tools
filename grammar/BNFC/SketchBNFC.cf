-- Grammar for the Sketch language in BNFC format
-- For more info see https://bnfc.digitalgrammars.com/

Prog . Program ::= [TopDecl] ;

TopDecl     . TopDecl ::= PkgDecl ;
TopInclude  . TopDecl ::= IncludeStmt ;
TopPkgStmt  . TopDecl ::= "package" Id ";" ;
TopInlinePkg. TopDecl ::= "package" Id PkgBody ;
TopPragma   . TopDecl ::= PragmaStmt ;

PkgBody. PkgBody ::= "{" [PkgDecl] "}" ;

PkgFunc  . PkgDecl ::= FunctionDecl ;
PkgField . PkgDecl ::= FieldDecl ";" ;
PkgStruct. PkgDecl ::= StructDecl ;
PkgADT   . PkgDecl ::= ADTDecl ;
PkgAsrt  . PkgDecl ::= SpecialAssertStmt ;

Include. IncludeStmt ::= "include" String ";" ;

Pragma   . PragmaStmt ::= "pragma" Id ";" ;
PragmaArg. PragmaStmt ::= "pragma" Id String ";" ;

Field. FieldDecl ::= VarDecl;

StmtLoop     . Stmt ::= LoopStmt ;
StmtMinRepeat. Stmt ::= MinRepeatStmt ;
StmtFork     . Stmt ::= ForkStmt ;
StmtSPMDFork . Stmt ::= SPMDForkStmt ;
StmtParFor   . Stmt ::= ParForStmt ;
StmtInsert   . Stmt ::= InsertBlock ;
StmtReorder  . Stmt ::= ReorderBlock ;
StmtAtomic   . Stmt ::= AtomicBlock ;
StmtBlock    . Stmt ::= Block ;
StmtFDecl    . Stmt ::= FDeclStmt ;
StmtVarDecl  . Stmt ::= VarDecl ";" ;
StmtExpr     . Stmt ::= ExprStmt ";" ;
StmtBreak    . Stmt ::= "break" ";" ;
StmtCont     . Stmt ::= "continue" ";" ;
StmtSwitch   . Stmt ::= SwitchStmt ;
StmtIfElse   . Stmt ::= IfElseStmt ;
StmtWhile    . Stmt ::= WhileStmt ;
StmtDoWhile  . Stmt ::= DoWhileStmt ";" ;
StmtFor      . Stmt ::= ForStmt ;
StmtAssume   . Stmt ::= AssumeStmt ";" ;
StmtAssert   . Stmt ::= AssertStmt ";" ;
StmtAssertMax. Stmt ::= AssertMaxStmt ";" ;
StmtHAssert  . Stmt ::= HAssertStmt ";" ;
StmtReturn   . Stmt ::= ReturnStmt ";" ;
StmtEmpty    . Stmt ::= ";" ;

FDecl. FDeclStmt ::= FunctionDecl ;

LoopId  . LoopStmt ::= "loop" "(" Id ":" RightExpr ")" PseudoBlock ;
RepeatId. LoopStmt ::= "repeat" "(" Id ":" RightExpr ")" PseudoBlock ;
Loop    . LoopStmt ::= "loop" "(" RightExpr ")" PseudoBlock ;
Repeat  . LoopStmt ::= "repeat" "(" RightExpr ")" PseudoBlock ;

MinRepeat. MinRepeatStmt ::= "minrepeat" PseudoBlock ;

Fork. ForkStmt ::= "fork" "(" VarDecl ";" RightExpr ")" PseudoBlock ;

SPMDFork  . SPMDForkStmt ::= "spmdfork" "(" RightExpr ")" PseudoBlock ;
SPMDForkId. SPMDForkStmt ::= "spmdfork" "(" Id ";" RightExpr ")" PseudoBlock ;

ParFor. ParForStmt ::= "parfor" "(" VarExpr "<-" RangeExp ")" PseudoBlock ;

Range  . RangeExp ::= RightExpr "until" RightExpr ;
RangeBy. RangeExp ::= RightExpr "until" RightExpr "by" RightExpr;

TypeParamId  . TypeParamsUse ::= "<" QualId "<" DataType ">>" ;
TypeParamBare. TypeParamsUse ::= "<" [DataType] ">" ;

QualId. QualId ::= Id "@" Id ;
NormId. QualId ::= Id ;

GlobalDataType. DataType ::= "global" DataTypeMain ;
NormalDataType. DataType ::= DataTypeMain ;
VoidDataType  . DataType ::= "void" ;
DataTypeNoParam  . DataTypeMain ::= DataTypeSpec [DataTypeParamList] ; 
DataTypeWithParam. DataTypeMain ::= DataTypeSpec TypeParamsUse [DataTypeParamList] ;
PrimitiveType . DataTypeSpec ::= PrimitiveType ;
DefinedType   . DataTypeSpec ::= QualId ;
DefinedTypeTmp. DataTypeSpec ::= "|" QualId "|" ;
DataTypeParamList. DataTypeParamList  ::= "[" [DataTypeParm] "]" ;
DataTypeParam       . DataTypeParm ::= ExprNamedParam ;
DataTypeParamBounded. DataTypeParm ::= ExprNamedParam "<:" Number ;

Boolean. PrimitiveType ::= "boolean" ;
Bit    . PrimitiveType ::= "bit" ;
Int    . PrimitiveType ::= "int" ;
Float  . PrimitiveType ::= "float" ;
Double . PrimitiveType ::= "double" ;
Fun    . PrimitiveType ::= "fun" ;
Char   . PrimitiveType ::= "char" ;

VarDecl. VarDecl ::= DataType [VarAssign] ;
VarNoAssign. VarAssign ::= Id ;
VarAssign  . VarAssign ::= Id "=" ExprOrLambda ; 

OptLambda. ExprOrLambda ::= LambdaExpr ;
OptExpr  . ExprOrLambda ::= RightExpr ;

Anno     . Anno ::= "@" Id "(" String ")" ;
AnnoEmpty. Anno ::= "@" Id "(" ")" ;

TypeParams. TypeParams ::= "<" [TypeParam] ">" ;
TypeParam. TypeParam ::= Id ;

FDeclWithBody. FunctionDecl ::= FuncDeclMain Block ;
FDeclOnly    . FunctionDecl ::= FuncDeclMain ";" ;
FDeclMain. FuncDeclMain ::=
    [Anno] [FuncMod] ReturnType Id OptionalTypeParams ParamDeclList FuncImpl FuncFixes ;
Serial   . FuncMod ::= "serial" ;
Harness  . FuncMod ::= "harness" ;
Generator. FuncMod ::= "generator" ;
Stencil  . FuncMod ::= "stencil" ;
Model    . FuncMod ::= "model" ;
TypeParamsEmpty. OptionalTypeParams ::= ;
TypeParamsOpt  . OptionalTypeParams ::= TypeParams ;
FuncImplEmpty. FuncImpl ::= ;
FuncImpl     . FuncImpl ::= "implements" Id ;
FunFixesEmpty. FuncFixes ::= ;
FuncFixes    . FuncFixes ::= "fixes" Id ;

ReturnType. ReturnType ::= DataType ;

PDeclList    . ParamDeclList ::= "(" [ParamDecl] ")" ;
PDeclImplList. ParamDeclList ::= "(" ImplParam [ParamDecl] ")" ;

ImplParam. ImplParam ::= "[" [ImplParamItem] "]" ;
ImplParamItem. ImplParamItem ::= "int" Id ;

PDecl   . ParamDecl ::= DataType Id ;
PDeclRef. ParamDecl ::= "ref" DataType Id ;

Block. Block ::= "{" [Stmt] "}" ;

Insert. InsertBlock ::=  "insert" Block "into" Block ;

Reorder. ReorderBlock ::= "reorder" Block ;

Atomic   . AtomicBlock ::= "atomic" Block ;
AtomicVal. AtomicBlock ::= "atomic" "(" RightExpr ")" Block ;

PseudoBlock. PseudoBlock ::= Stmt ;

Return   . ReturnStmt ::= "return" ;
ReturnVal. ReturnStmt ::= "return" RightExpr ;

AssmSimple. AssumeStmtSimple ::= "assume" RightExpr ;
AssmNoMsg. AssumeStmt ::= AssumeStmtSimple ;
AssmMsg  . AssumeStmt ::= AssumeStmtSimple ":" String ;

AsrtSimple. AssertStmtSimple ::= "assert" RightExpr ; 
SpecialAsrt. SpecialAssertStmt ::=
    SpecialAssertLet "{" SpecialAssertAssume [AssertStmtSimple] "}" ;
SpecialAsrtLet      . SpecialAssertLet ::= "let" ;
SpecialAsrtLetAssign. SpecialAssertLet ::= "let" [VarAssignExpr] ;
VarAssignExpr. VarAssignExpr ::= Id "=" RightExpr ;
SpecialAsrtAssmEmpty. SpecialAssertAssume ::= ;
SpecialAsrtAssm     . SpecialAssertAssume ::= "assume" RightExpr ;

Asrt   . AssertStmt ::= AssertStmtCore ;
AsrtMsg. AssertStmt ::= AssertStmtCore ":" String ;
AsrtCore  . AssertStmtCore ::= "assert" RightExpr ;
HDAsrtCore. AssertStmtCore ::= "h_assert" RightExpr ;

HAsrt   . HAssertStmt ::= "hassert" RightExpr ;
HAsrtMsg. HAssertStmt ::= "hassert" RightExpr ":" String ;

AsrtMax   . AssertMaxStmt ::= AssertMaxStmtCore ;
AsrtMaxMsg. AssertMaxStmt ::= AssertMaxStmtCore ":" String ;
AsrtMaxCore     . AssertMaxStmtCore ::= "assert_max" RightExpr ;
AsrtMaxCoreRefer. AssertMaxStmtCore ::= "assert_max" "\\" RightExpr ;

Switch. SwitchStmt ::=
    "switch" "(" Id ")" "{" [SwitchStmtCase] SwitchStmtFallThru "}" ;
SwitchCase. SwitchStmtCase ::= "case" Id ":" PseudoBlock ;
SwitchDefaultEmpty. SwitchStmtFallThru ::= ;
SwitchDefault     . SwitchStmtFallThru ::= "default" ":" PseudoBlock ;
SwitchRepeatCase  . SwitchStmtFallThru ::= "repeat_case" ":" PseudoBlock ;

If. IfStmt ::= "if" "(" RightExpr ")" PseudoBlock ;
IfOnly. IfElseStmt ::= IfStmt;
IfElse. IfElseStmt ::= IfStmt "else" PseudoBlock ;

While. WhileStmt ::= "while" "(" RightExpr ")" PseudoBlock ;

DoWhile. DoWhileStmt ::= "do" PseudoBlock "while" "(" RightExpr ")" ;

For. ForStmt ::=
    "for" "(" ForInitStmt ";" ForCondStmt ";" ForIncrStmt ")" PseudoBlock ;
ForCond   . ForCondStmt ::= RightExpr ;
ForCondInf. ForCondStmt ::= ;

ForInitEmpty. ForInitStmt ::= ;
ForInitDecl . ForInitStmt ::= VarDecl ;
ForInitExpr . ForInitStmt ::= ExprStmt;

ForIncrEmpty. ForIncrStmt ::= ;
ForIncr     . ForIncrStmt ::= ExprStmt ;

Expr. ExprStmt ::= AssignExpr ;

AssignExpr        . AssignExpr ::= PrefixExpr AssignOp ExprOrLambda ;
AssignExprNoAssign. AssignExpr ::= PrefixExpr ;

FuncCall. FuncCall ::= QualId FuncCallParams ;

ExprGet. ExprGet ::= "??" "(" "{" ExprGetParams "}" ")" ;

ExprGetParams. ExprGetParams ::= [ExprNamedParam] ;

FuncCallParams. FuncCallParams ::= "(" [ExprNamedParam] ")" ;

Lambda. LambdaExpr ::= "(" [LambdaParam] ")" "->" RightExpr ;
LambdaParam. LambdaParam ::= Id ;

ConstrParams     . ConstrParams ::= "(" ExprNamedParamMixedSeq ")" ;
ExprNamedParamMixedSeqEmpty. ExprNamedParamMixedSeq ::= ;
ExprNamedParamMixedSeqFirst. ExprNamedParamMixedSeq ::= VarAssignExpr ;
ExprNamedParamMixedSeqCont . ExprNamedParamMixedSeq ::=
    ExprNamedParamMixedSeq "," ExprNamedParam ;

ExprNamedParamAssign. ExprNamedParam ::= Id "=" ExprOrLambda ;
ExprNamedParam      . ExprNamedParam ::= ExprOrLambda ;

RightExprNotAgmax. RightExprNotAgmax ::= TernaryExpr ;

RightExpr. RightExpr ::= RightExprNotAgmax ;

ArrInit. ArrInit ::= "{" [RightExpr] "}" ;

TernaryExprNone. TernaryExpr ::= LogicOrExpr ;
TernaryExpr    . TernaryExpr ::= LogicOrExpr "?" TernaryExpr ":" TernaryExpr ;

LogicOrExpr. LogicOrExpr ::= [LogicAndExpr] ;

LogicAndExpr. LogicAndExpr ::= [BitwiseOrExpr] ;

BitwiseOrExpr. BitwiseOrExpr ::= [BitWiseXorExpr] ;

BitWiseXorExpr. BitWiseXorExpr ::= [BitWiseAndExpr];

BitWiseAndExpr. BitWiseAndExpr ::= [EqualExpr] ;

EqualExpr. EqualExpr ::= [EqualExprItem] ;
_. EqualExprItem ::= CompareExpr;
_. EqualOp ::= "==" ;
_. EqualOp ::= "===" ;
_. EqualOp ::= "!=" ;

CompareExpr. CompareExpr ::= [CompareExprItem] ;
_. CompareExprItem ::= ShiftExpr ;
_. CompareOp ::= "<" ;
_. CompareOp ::= "<=" ;
_. CompareOp ::= ">" ;
_. CompareOp ::= ">=" ;
_. CompareOp ::= ".<" ;
_. CompareOp ::= ".>" ;
_. CompareOp ::= ".<=" ;
_. CompareOp ::= ".>=" ;

ShiftExpr. ShiftExpr ::= [ShiftExprItem] ;
_. ShiftExprItem ::= AddExpr ;
_. ShiftOp ::= "<<" ;
_. ShiftOp ::= ">>" ;

AddExpr. AddExpr ::= [AddExprItem];
_. AddExprItem ::= MultExpr ;
_. AddOp ::= "+" ;
_. AddOp ::= "-" ;
_. AddOp ::= "{|}" ;
_. AddOp ::= ".+" ;
_. AddOp ::= ".-" ;

MultExpr. MultExpr ::= [MultExprItem];
_. MultExprItem ::= PrefixExpr ;
_. MultOp ::= "*" ;
_. MultOp ::= "/" ;
_. MultOp ::= "%" ;
_. MultOp ::= ".*" ;
_. MultOp ::= "./" ;
_. MultOp ::= ".%" ;

_              . PrefixExpr ::= PrefixExprNoMinus ;
PrefixExprMinus. PrefixExpr ::= "-" PrefixExpr ;

PrefixExprCast. PrefixExprNoMinus ::= CastExpr ;
PrefixExprPost. PrefixExprNoMinus ::= PostfixExpr ;
PrefixExprNM  . PrefixExprNoMinus ::= PrefixOpNM PrefixExpr ;
_. PrefixOpNM ::= "++" ;
_. PrefixOpNM ::= "--" ;
_. PrefixOpNM ::= "!" ;
_. PrefixOpNM ::= "~" ;

CastExpr. CastExpr ::= "(" DataType ")" PrefixExprNoMinus ;

PostfixExpr. PostfixExpr ::= PrimaryExpr [PostfixIncr] ;
_. PostfixIncr ::= "++" ;
_. PostfixIncr ::= "--" ;

PrimaryExpr. PrimaryExpr ::= TminicValueExpr [PrimaryPostfix] ;
PrimaryMemberAcc. PrimaryPostfix ::= "." MemberRef ;
PrimaryArrayAcc . PrimaryPostfix ::= "[" ArrayRange "]" ;
MemberRefName. MemberRef ::= Id ;
MemberRefHole. MemberRef ::= "??" ;
MemberRefType. MemberRef ::= "{" DataType "}" ;

NestedExpr. TminicValueExpr ::= "(" RightExpr ")" ;
_         . TminicValueExpr ::= ExprGet ;
_         . TminicValueExpr ::= FuncCall ;
_         . TminicValueExpr ::= ConstructorExpr ;
_         . TminicValueExpr ::= VarExpr ;
_         . TminicValueExpr ::= ConstantExpr ;
_         . TminicValueExpr ::= ArrInit ;
_         . TminicValueExpr ::= Regen;

-- Regen is parsed differently to the original Sketch parser
-- The original parser does not parse Regen structures and just reads the whole
-- string in as is and processes it later.
-- We handle this similarly by parsing the inners of Regen expressions as token
-- streams and leave it to be processed later.
Regen. Regen ::= "{|" [RegenBranch] "|}" ;
RegenBranch    . RegenBranch ::=  "(" [RegenToken] ")" ;
RegenBranchNoOr. RegenBranch ::=  [RegenTokenNoOr] ;

ConstructorExprNew         . ConstructorExpr ::= "new" QualIdHole ConstrParams ; 
ConstructorExprNewTypeParam. ConstructorExpr ::= "new" QualIdHole TypeParamsUse ConstrParams ;
ConstructorAdHoc           . ConstructorExpr ::= "|" QualId "|" ConstrParams ;
QualIdHole. QualIdHole ::= Id "@" IdHole ;
_         . QualIdHole ::= IdHole;
_. IdHole ::= Id ;
_. IdHole ::= "??" ;

VarExpr. VarExpr ::= Id ;

ArrayRange      . ArrayRange ::= [ExprNamedParamNonEmptyList] ;
ArrayRangeEnd   . ArrayRange ::= [ExprNamedParamNonEmptyList] ":" RightExpr ;
ArrayRangeOffset. ArrayRange ::= [ExprNamedParamNonEmptyList] ":" ":" RightExpr ;
_. ExprNamedParamNonEmptyList ::= ExprNamedParam ;

ConstHex  . ConstantExpr ::= HQuan ;
ConstNum  . ConstantExpr ::= Number ;
ConstChar . ConstantExpr ::= Char ;
ConstStr  . ConstantExpr ::= String ;
ConstTrue . ConstantExpr ::= "true" ;
ConstFalse. ConstantExpr ::= "false" ;
ConstNull . ConstantExpr ::= "null" ;
ConstHole . ConstantExpr ::= "{*}" ;
ConstHole2. ConstantExpr ::= "??" ;
ConstBHole. ConstantExpr ::= BoundedHole; 
ConstAHole. ConstantExpr ::= "**" ;
ConstSHole. ConstantExpr ::= "??s" ;
ConstLVar . ConstantExpr ::= LocalVariable; 
BoundedHole        . BoundedHole ::= "??" "(" AddExpr ")" ;
BoundedHoleStartEnd. BoundedHole ::= "??" "(" AddExpr "," AddExpr ")" ;

LocalVariable. LocalVariable ::= "$" "(" DataType ")" ;

ADTDecl. ADTDecl ::= "adt" Id OptionalTypeParams "{" [ADTBodyItem] "}" ;
_           . ADTBodyItem ::= ADTDecl ;
_           . ADTBodyItem ::= StructInsideADTDecl ;
ADTParamDecl. ADTBodyItem ::= ParamDecl ";" ;
_           . ADTBodyItem ::= Anno ;

StructInsideADTDecl. StructInsideADTDecl ::= Id "{" [StructBodyItem] "}" ;
_. StructBodyItem ::= ParamDecl ";" ;
_. StructBodyItem ::= Anno ;

StructDecl. StructDecl ::=
    [Anno] "struct" Id OptionalTypeParams OptionalExtends "{" [StructBodyItem] "}" ;
_              . OptionalExtends ::= ;
OptionalExtends. OptionalExtends ::= "extends" Id ;

-- Wildcard category for Regen expressions
-- TODO: Finish wildcard category
_. RegenToken ::= "|" ;
_. RegenToken ::= RegenTokenNoOr ;
NestedRegen. RegenTokenNoOr ::= Regen ;
_          . RegenTokenNoOr ::= Id ;

-- List Defs

terminator TopDecl "" ;
terminator PkgDecl "" ;
separator nonempty VarAssign "," ;
separator nonempty DataType "," ;
terminator DataTypeParamList "" ;
separator DataTypeParm "," ;
terminator Anno "" ;
separator nonempty TypeParam "," ;
terminator FuncMod "" ;
separator ParamDecl "," ;
separator ImplParamItem "," ;
terminator Stmt "" ;
separator nonempty VarAssignExpr "," ;
terminator nonempty AssertStmtSimple ";" ;
terminator SwitchStmtCase "" ;
separator ExprNamedParam "," ;
separator LambdaParam "," ;
separator RightExpr "," ;
separator nonempty LogicAndExpr "||" ;
separator nonempty BitwiseOrExpr "&&" ;
separator nonempty BitWiseXorExpr "|" ;
separator nonempty BitWiseAndExpr "^" ;
separator nonempty EqualExpr "&" ;
(:[]). [EqualExprItem] ::= EqualExprItem ;
(:)  . [EqualExprItem] ::= EqualExprItem EqualOp [EqualExprItem] ;
(:[]). [CompareExprItem] ::= CompareExprItem ;
(:)  . [CompareExprItem] ::= CompareExprItem CompareOp [CompareExprItem] ;
(:[]). [ShiftExprItem] ::= ShiftExprItem ;
(:)  . [ShiftExprItem] ::= ShiftExprItem ShiftOp [ShiftExprItem] ;
(:[]). [AddExprItem] ::= AddExprItem ;
(:)  . [AddExprItem] ::= AddExprItem AddOp [AddExprItem] ;
(:[]). [MultExprItem] ::= MultExprItem ;
(:)  . [MultExprItem] ::= MultExprItem MultOp [MultExprItem] ;
terminator PostfixIncr "" ;
terminator PrimaryPostfix "" ;
separator RegenBranch "|" ;
terminator RegenToken "" ;
terminator RegenTokenNoOr "" ;
separator nonempty ExprNamedParamNonEmptyList "," ;
terminator ADTBodyItem "" ;
terminator StructBodyItem "" ;

-- Tokens

-- NOTE: Currently we are using BNFC pre-defined chars and strings literals
-- there may be differences between these and original Sketch lang definitions
-- refer to ANTLR2 grammar for original definitions
token Id (((letter|'_') (letter|digit|'_')*)|
    {"op.+"}| {"op.-"}| {"op.*"}| {"op./"}| {"op.%"}| {"op.="}| {"op.<"}) ;
token Number (digit+ ('.' digit+)? (('e'|'E') ('+'|'-')? digit+)? 'i'? ) ;
token HQuan {"0x"} ( digit | ["abcdefABCDEF"] )+ ;

-- Op Tokens for easier expression handling as lists
token AssignOp '=' | {"+="} | {"-="} | {"*="} | {"/="} | {".="} ;
