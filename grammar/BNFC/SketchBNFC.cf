-- Grammar for the Sketch language in BNFC format
-- For more info see https://bnfc.digitalgrammars.com/

Prog . Program ::= [TopDecl] ;

TopDecl     . TopDecl ::= PkgDecl ;
TopInclude  . TopDecl ::= IncludeStmt ;
TopPkgStmt  . TopDecl ::= "package" Id ";" ;
TopInlinePkg. TopDecl ::= "package" Id PkgBody ;
TopPragma   . TopDecl ::= PragmaStmt ;

PkgBody. PkgBody ::= "{" [PkgDecl] "}" ;

PkgFunc  . PkgDecl ::= FunctionDecl ;
PkgField . PkgDecl ::= FieldDecl ";" ;
PkgStruct. PkgDecl ::= StructDecl ;
PkgADT   . PkgDecl ::= ADTDecl ;
PkgAsrt  . PkgDecl ::= SpecialAssertStmt ;

Include. IncludeStmt ::= "include" String ";" ;

Pragma   . PragmaStmt ::= "pragma" Id ";" ;
PragmaArg. PragmaStmt ::= "pragma" Id String ";" ;

Field. FieldDecl ::= VarDecl;

StmtLoop     . Stmt ::= LoopStmt ;
StmtMinRepeat. Stmt ::= MinRepeatStmt ;
StmtFork     . Stmt ::= ForkStmt ;
StmtSPMDFork . Stmt ::= SPMDForkStmt ;
StmtParFor   . Stmt ::= ParForStmt ;
StmtInsert   . Stmt ::= InsertBlock ;
StmtReorder  . Stmt ::= ReorderBlock ;
StmtAtomic   . Stmt ::= AtomicBlock ;
StmtBlock    . Stmt ::= Block ;
StmtFDecl    . Stmt ::= FDeclStmt ;
StmtVarDecl  . Stmt ::= VarDecl ";" ;
StmtExpr     . Stmt ::= ExprStmt ";" ;
StmtBreak    . Stmt ::= "break" ";" ;
StmtCont     . Stmt ::= "continue" ";" ;
StmtSwitch   . Stmt ::= SwitchStmt ;
StmtIfElse   . Stmt ::= IfElseStmt ;
StmtWhile    . Stmt ::= WhileStmt ;
StmtDoWhile  . Stmt ::= DoWhileStmt ";" ;
StmtFor      . Stmt ::= ForStmt ;
StmtAssume   . Stmt ::= AssumeStmt ";" ;
StmtAssert   . Stmt ::= AssertStmt ";" ;
StmtAssertMax. Stmt ::= AssertMaxStmt ";" ;
StmtHAssert  . Stmt ::= HAssertStmt ";" ;
StmtReturn   . Stmt ::= ReturnStmt ";" ;
StmtEmpty    . Stmt ::= ";" ;

FDecl. FDeclStmt ::= FunctionDecl ;

LoopId  . LoopStmt ::= "loop" "(" Id ":" RightExpr ")" PseudoBlock ;
RepeatId. LoopStmt ::= "repeat" "(" Id ":" RightExpr ")" PseudoBlock ;
Loop    . LoopStmt ::= "loop" "(" RightExpr ")" PseudoBlock ;
Repeat  . LoopStmt ::= "repeat" "(" RightExpr ")" PseudoBlock ;

MinRepeat. MinRepeatStmt ::= "minrepeat" PseudoBlock ;

Fork. ForkStmt ::= "fork" "(" VarDecl ";" RightExpr ")" PseudoBlock ;

SPMDFork  . SPMDForkStmt ::= "spmdfork" "(" RightExpr ")" PseudoBlock ;
SPMDForkId. SPMDForkStmt ::= "spmdfork" "(" Id ";" RightExpr ")" PseudoBlock ;

ParFor. ParForStmt ::= "parfor" "(" VarExpr "<-" RangeExp ")" PseudoBlock ;

Range  . RangeExp ::= RightExpr "until" RightExpr ;
RangeBy. RangeExp ::= RightExpr "until" RightExpr "by" RightExpr;

TypeParamId  . TypeParamsUse ::= "<" QualId "<" DataType ">>" ;
TypeParamBare. TypeParamsUse ::= "<" [DataType] ">" ;

QualId. QualId ::= Id "@" Id ;
NormId. QualId ::= Id ;

GlobalDataType. DataType ::= "global" DataTypeMain ;
NormalDataType. DataType ::= DataTypeMain ;
VoidDataType  . DataType ::= "void" ;
DataTypeNoParam  . DataTypeMain ::= DataTypeSpec [DataTypeParamList] ; 
DataTypeWithParam. DataTypeMain ::= DataTypeSpec TypeParamsUse [DataTypeParamList] ;
PrimitiveType . DataTypeSpec ::= PrimitiveType ;
DefinedType   . DataTypeSpec ::= QualId ;
DefinedTypeTmp. DataTypeSpec ::= "|" QualId "|" ;
DataTypeParamList. DataTypeParamList  ::= "[" [DataTypeParm] "]" ;
DataTypeParam       . DataTypeParm ::= ExprNamedParam ;
DataTypeParamBounded. DataTypeParm ::= ExprNamedParam "<:" Number ;

Boolean. PrimitiveType ::= "boolean" ;
Bit    . PrimitiveType ::= "bit" ;
Int    . PrimitiveType ::= "int" ;
Float  . PrimitiveType ::= "float" ;
Double . PrimitiveType ::= "double" ;
Fun    . PrimitiveType ::= "fun" ;
Char   . PrimitiveType ::= "char" ;

VarDecl. VarDecl ::= DataType [VarAssign] ;
VarNoAssign. VarAssign ::= Id ;
VarAssign  . VarAssign ::= Id "=" ExprOrLambda ; 

OptLambda. ExprOrLambda ::= LambdaExpr ;
OptExpr  . ExprOrLambda ::= RightExpr ;

Anno     . Anno ::= "@" Id "(" String ")" ;
AnnoEmpty. Anno ::= "@" Id "(" ")" ;

TypeParams. TypeParams ::= "<" [TypeParam] ">" ;
TypeParam. TypeParam ::= Id ;

FDeclWithBody. FunctionDecl ::= FuncDeclMain Block ;
FDeclOnly    . FunctionDecl ::= FuncDeclMain ";" ;
FDeclMain. FuncDeclMain ::=
    [Anno] [FuncMod] ReturnType Id OptionalTypeParams ParamDeclList FuncImpl FuncFixes ;
Serial   . FuncMod ::= "serial" ;
Harness  . FuncMod ::= "harness" ;
Generator. FuncMod ::= "generator" ;
Stencil  . FuncMod ::= "stencil" ;
Model    . FuncMod ::= "model" ;
TypeParamsEmpty. OptionalTypeParams ::= ;
TypeParamsOpt  . OptionalTypeParams ::= TypeParams ;
FuncImplEmpty. FuncImpl ::= ;
FuncImpl     . FuncImpl ::= "implements" Id ;
FunFixesEmpty. FuncFixes ::= ;
FuncFixes    . FuncFixes ::= "fixes" Id ;

ReturnType. ReturnType ::= DataType ;

PDeclList    . ParamDeclList ::= "(" [ParamDecl] ")" ;
PDeclImplList. ParamDeclList ::= "(" ImplParam [ParamDecl] ")" ;

ImplParam. ImplParam ::= "[" [ImplParamItem] "]" ;
ImplParamItem. ImplParamItem ::= "int" Id ;

PDecl   . ParamDecl ::= DataType Id ;
PDeclRef. ParamDecl ::= "ref" DataType Id ;

Block. Block ::= "{" [Stmt] "}" ;

Insert. InsertBlock ::=  "insert" Block "into" Block ;

Reorder. ReorderBlock ::= "reorder" Block ;

Atomic   . AtomicBlock ::= "atomic" Block ;
AtomicVal. AtomicBlock ::= "atomic" "(" RightExpr ")" Block ;

PseudoBlock. PseudoBlock ::= Stmt ;

Return   . ReturnStmt ::= "return" ;
ReturnVal. ReturnStmt ::= "return" RightExpr ;

AssmSimple. AssumeStmtSimple ::= "assume" RightExpr ;
AssmNoMsg. AssumeStmt ::= AssumeStmtSimple ;
AssmMsg  . AssumeStmt ::= AssumeStmtSimple ":" String ;

AsrtSimple. AssertStmtSimple ::= "assert" RightExpr ; 
SpecialAsrt. SpecialAssertStmt ::=
    SpecialAssertLet "{" SpecialAssertAssume [AssertStmtSimple] "}" ;
SpecialAsrtLet      . SpecialAssertLet ::= "let" ;
SpecialAsrtLetAssign. SpecialAssertLet ::= "let" [VarAssignExpr] ;
VarAssignExpr. VarAssignExpr ::= Id "=" RightExpr ;
SpecialAsrtAssmEmpty. SpecialAssertAssume ::= ;
SpecialAsrtAssm     . SpecialAssertAssume ::= "assume" RightExpr ;

Asrt   . AssertStmt ::= AssertStmtCore ;
AsrtMsg. AssertStmt ::= AssertStmtCore ":" String ;
AsrtCore  . AssertStmtCore ::= "assert" RightExpr ;
HDAsrtCore. AssertStmtCore ::= "h_assert" RightExpr ;

HAsrt   . HAssertStmt ::= "hassert" RightExpr ;
HAsrtMsg. HAssertStmt ::= "hassert" RightExpr ":" String ;

AsrtMax   . AssertMaxStmt ::= AssertMaxStmtCore ;
AsrtMaxMsg. AssertMaxStmt ::= AssertMaxStmtCore ":" String ;
AsrtMaxCore     . AssertMaxStmtCore ::= "assert_max" RightExpr ;
AsrtMaxCoreRefer. AssertMaxStmtCore ::= "assert_max" "\\" RightExpr ;

Switch. SwitchStmt ::=
    "switch" "(" Id ")" "{" [SwitchStmtCase] SwitchStmtFallThru "}" ;
SwitchCase. SwitchStmtCase ::= "case" Id ":" PseudoBlock ;
SwitchDefaultEmpty. SwitchStmtFallThru ::= ;
SwitchDefault     . SwitchStmtFallThru ::= "default" ":" PseudoBlock ;
SwitchRepeatCase  . SwitchStmtFallThru ::= "repeat_case" ":" PseudoBlock ;

If. IfStmt ::= "if" "(" RightExpr ")" PseudoBlock ;
IfOnly. IfElseStmt ::= IfStmt;
IfElse. IfElseStmt ::= IfStmt "else" PseudoBlock ;

While. WhileStmt ::= "while" "(" RightExpr ")" PseudoBlock ;

DoWhile. DoWhileStmt ::= "do" PseudoBlock "while" "(" RightExpr ")" ;

For. ForStmt ::=
    "for" "(" ForInitStmt ";" ForCondStmt ";" ForIncrStmt ")" PseudoBlock ;
ForCond   . ForCondStmt ::= RightExpr ;
ForCondInf. ForCondStmt ::= ;

ForInitEmpty. ForInitStmt ::= ;
ForInitDecl . ForInitStmt ::= VarDecl ;
ForInitExpr . ForInitStmt ::= ExprStmt;

ForIncrEmpty. ForIncrStmt ::= ;
ForIncr     . ForIncrStmt ::= ExprStmt ;

Expr. ExprStmt ::= AssignExpr ;

AssignExpr        . AssignExpr ::= PrefixExpr AssignOp ExprOrLambda ;
AssignExprNoAssign. AssignExpr ::= PrefixExpr ;
AssignOp      . AssignOp ::= "=" ;
PlusAssignOp  . AssignOp ::= "+=" ;
MinusAssignOp . AssignOp ::= "-=" ;
MultiAssignOp . AssignOp ::= "*=" ;
DivideAssignOp. AssignOp ::= "/=" ;
DotAssignOp   . AssignOp ::= ".=" ;

FuncCall. FuncCall ::= QualId FuncCallParams ;

ExprGet. ExprGet ::= "??" "(" "{" ExprGetParams "}" ")" ;

ExprGetParams. ExprGetParams ::= [ExprNamedParam] ;

FuncCallParams. FuncCallParams ::= "(" [ExprNamedParam] ")" ;

Lambda. LambdaExpr ::= "(" [LambdaParam] ")" "->" RightExpr ;
LambdaParam. LambdaParam ::= Id ;

ConstrParams     . ConstrParams ::= "(" ExprNamedParamMixedSeq ")" ;
ExprNamedParamMixedSeqEmpty. ExprNamedParamMixedSeq ::= ;
ExprNamedParamMixedSeqFirst. ExprNamedParamMixedSeq ::= VarAssignExpr ;
ExprNamedParamMixedSeqCont . ExprNamedParamMixedSeq ::=
    ExprNamedParamMixedSeq "," ExprNamedParam ;

ExprNamedParamAssign. ExprNamedParam ::= Id "=" ExprOrLambda ;
ExprNamedParam      . ExprNamedParam ::= ExprOrLambda ;

RightExprNotAgmax. RightExprNotAgmax ::= TernaryExpr ;

RightExpr. RightExpr ::= RightExprNotAgmax ;

ArrInit. ArrInit ::= "{" [RightExpr] "}" ;

TernaryExprNone. TernaryExpr ::= LogicOrExpr ;
TernaryExpr    . TernaryExpr ::= LogicOrExpr "?" TernaryExpr ":" TernaryExpr ;

LogicOrExpr. LogicOrExpr ::= [LogicAndExpr] ;

LogicAndExpr. LogicAndExpr ::= [BitwiseOrExpr] ;

BitwiseOrExpr. BitwiseOrExpr ::= [BitWiseXorExpr] ;

BitWiseXorExpr. BitWiseXorExpr ::= [BitWiseAndExpr];

BitWiseAndExpr. BitWiseAndExpr ::= [EqualExpr] ;

EqualExpr. EqualExpr ::= EqualExprItems ;
EqualExprItemsFirst. EqualExprItems ::= CompareExpr ;
EqualExprItemsCont . EqualExprItems ::= CompareExpr EqualOp EqualExprItems;
EqualOp   . EqualOp ::= "==" ;
TriEqualOp. EqualOp ::= "===" ;
NonEqualOp. EqualOp ::= "!=" ;

CompareExpr. CompareExpr ::= CompareExprItems ;
CompareExprItemsFirst. CompareExprItems ::= ShiftExpr ;
CompareExprItemsCont . CompareExprItems ::= ShiftExpr CompareOp CompareExprItems;
LTOp. CompareOp ::= "<" ;
LEOp. CompareOp ::= "<=" ;
GTOp. CompareOp ::= ">" ;
GEOp. CompareOp ::= ">=" ;
DotLTOp. CompareOp ::= ".<" ;
DotGTOp. CompareOp ::= ".>" ;
DotLEOp. CompareOp ::= ".<=" ;
DotGEOp. CompareOp ::= ".>=" ;

ShiftExpr. ShiftExpr ::= ShiftExprItems ;
ShiftExprItemsFirst. ShiftExprItems ::= AddExpr ;
ShiftExprItemsCont . ShiftExprItems ::= AddExpr ShiftOp ShiftExprItems;
LShiftOp. ShiftOp ::= "<<" ;
RShiftOp. ShiftOp ::= ">>" ;

AddExpr. AddExpr ::= AddExprItems;
AddExprItemsFirst. AddExprItems ::= MultExpr ;
AddExprItemsCont . AddExprItems ::= MultExpr AddOp AddExprItems;
PlusOp    . AddOp ::= "+" ;
MinusOp   . AddOp ::= "-" ;
SelectOp  . AddOp ::= "{|}" ;
DotPlusOp . AddOp ::= ".+" ;
DotMinusOp. AddOp ::= ".-" ;

MultExpr. MultExpr ::= MultExprItems;
MultExprItemsFirst. MultExprItems ::= PrefixExpr ;
MultExprItemsCont . MultExprItems ::= PrefixExpr MultOp MultExprItems;
MultOp     . MultOp ::= "*" ;
DivideOp   . MultOp ::= "/" ;
ModOp      . MultOp ::= "%" ;
DotMultOp  . MultOp ::= ".*" ;
DotDivideOp. MultOp ::= "./" ;
DotModOp   . MultOp ::= ".%" ;

PrefixExpr     . PrefixExpr ::= PrefixExprNoMinus ;
PrefixExprMinus. PrefixExpr ::= "-" PrefixExpr ;

PrefixExprCast. PrefixExprNoMinus ::= CastExpr ;
PrefixExprPost. PrefixExprNoMinus ::= PostfixExpr ;
PrefixExprNM  . PrefixExprNoMinus ::= PrefixOpNM PrefixExpr ;
IncrOp. PrefixOpNM ::= "++" ;
DecrOp. PrefixOpNM ::= "--" ;
NotOp . PrefixOpNM ::= "!" ;
InvtOp. PrefixOpNM ::= "~" ;

CastExpr. CastExpr ::= "(" DataType ")" PrefixExprNoMinus ;

PostfixExpr. PostfixExpr ::= PrimaryExpr [PostfixIncr] ;
PostIncrOp. PostfixIncr ::= "++" ;
PostDecrOp. PostfixIncr ::= "--" ;

PrimaryExpr. PrimaryExpr ::= TminicValueExpr [PrimaryPostfix] ;
PrimaryMemberAcc. PrimaryPostfix ::= "." MemberRef ;
PrimaryArrayAcc . PrimaryPostfix ::= "[" ArrayRange "]" ;
MemberRefName. MemberRef ::= Id ;
MemberRefHole. MemberRef ::= "??" ;
MemberRefType. MemberRef ::= "{" DataType "}" ;

TminicNestedExpr. TminicValueExpr ::= "(" RightExpr ")" ;
TminicExprGet   . TminicValueExpr ::= ExprGet ;
TminicFuncCall  . TminicValueExpr ::= FuncCall ;
TminicConstruct . TminicValueExpr ::= ConstructorExpr ;
TminicVar       . TminicValueExpr ::= VarExpr ;
TminicConst     . TminicValueExpr ::= ConstantExpr ;
TminicArrInit   . TminicValueExpr ::= ArrInit ;
TminicRegen     . TminicValueExpr ::= Regen;

-- Regen is parsed differently to the original Sketch parser
-- The original parser does not parse Regen structures and just reads the whole
-- string in as is and processes it later.
-- We handle this similarly by parsing the inners of Regen expressions as token
-- streams and leave it to be processed later.
Regen. Regen ::= "{|" [RegenBranch] "|}" ;
RegenBranch    . RegenBranch ::=  "(" [RegenToken] ")" ;
RegenBranchNoOr. RegenBranch ::=  [RegenTokenNoOr] ;

ConstructorExprNew         . ConstructorExpr ::= "new" QualIdHole ConstrParams ; 
ConstructorExprNewTypeParam. ConstructorExpr ::= "new" QualIdHole TypeParamsUse ConstrParams ;
ConstructorTmp             . ConstructorExpr ::= "|" QualId "|" ConstrParams ;
QualIdHole. QualIdHole ::= Id "@" IdHole ;
NormIdHole. QualIdHole ::= IdHole;
OptId  . IdHole ::= Id ;
OptHole. IdHole ::= "??" ;

VarExpr. VarExpr ::= Id ;

ArrayRange      . ArrayRange ::= [ExprNamedParamNonEmptyList] ;
ArrayRangeEnd   . ArrayRange ::= [ExprNamedParamNonEmptyList] ":" RightExpr ;
ArrayRangeOffset. ArrayRange ::= [ExprNamedParamNonEmptyList] ":" ":" RightExpr ;
ExprNamedParamNonEmptyList. ExprNamedParamNonEmptyList ::= ExprNamedParam ;

ConstHex  . ConstantExpr ::= HQuan ;
ConstNum  . ConstantExpr ::= Number ;
ConstChar . ConstantExpr ::= Char ;
ConstStr  . ConstantExpr ::= String ;
ConstTrue . ConstantExpr ::= "true" ;
ConstFalse. ConstantExpr ::= "false" ;
ConstNull . ConstantExpr ::= "null" ;
ConstHole . ConstantExpr ::= "{*}" ;
ConstHole2. ConstantExpr ::= "??" ;
ConstBHole. ConstantExpr ::= BoundedHole; 
ConstAHole. ConstantExpr ::= "**" ;
ConstSHole. ConstantExpr ::= "??s" ;
ConstLVar . ConstantExpr ::= LocalVariable; 
BoundedHole        . BoundedHole ::= "??" "(" AddExpr ")" ;
BoundedHoleStartEnd. BoundedHole ::= "??" "(" AddExpr "," AddExpr ")" ;

LocalVariable. LocalVariable ::= "$" "(" DataType ")" ;

ADTDecl. ADTDecl ::= "adt" Id OptionalTypeParams "{" [ADTBodyItem] "}" ;
NestedADTDecl. ADTBodyItem ::= ADTDecl ;
ADTDeclStruct. ADTBodyItem ::= StructInsideADTDecl ;
ADTParamDecl . ADTBodyItem ::= ParamDecl ";" ;
ADTAnno      . ADTBodyItem ::= Anno ;

StructInsideADTDecl. StructInsideADTDecl ::= Id "{" [StructBodyItem] "}" ;
StructParamDecl. StructBodyItem ::= ParamDecl ";" ;
StructAnno     . StructBodyItem ::= Anno ;

StructDecl. StructDecl ::=
    [Anno] "struct" Id OptionalTypeParams OptionalExtends "{" [StructBodyItem] "}" ;
OptExtendsEmpty. OptionalExtends ::= ;
OptExtends     . OptionalExtends ::= "extends" Id ;

-- Wildcard category for Regen expressions
-- TODO: Finish wildcard category
RegenTokenOr. RegenToken ::= "|" ;
RegenToken  . RegenToken ::= RegenTokenNoOr ;
NestedRegen. RegenTokenNoOr ::= Regen ;
RegenId    . RegenTokenNoOr ::= Id ;

-- List Defs

terminator TopDecl "" ;
terminator PkgDecl "" ;
separator nonempty VarAssign "," ;
separator nonempty DataType "," ;
terminator DataTypeParamList "" ;
separator DataTypeParm "," ;
terminator Anno "" ;
separator nonempty TypeParam "," ;
terminator FuncMod "" ;
separator ParamDecl "," ;
separator ImplParamItem "," ;
terminator Stmt "" ;
separator nonempty VarAssignExpr "," ;
terminator nonempty AssertStmtSimple ";" ;
terminator SwitchStmtCase "" ;
separator ExprNamedParam "," ;
separator LambdaParam "," ;
separator RightExpr "," ;
separator nonempty LogicAndExpr "||" ;
separator nonempty BitwiseOrExpr "&&" ;
separator nonempty BitWiseXorExpr "|" ;
separator nonempty BitWiseAndExpr "^" ;
separator nonempty EqualExpr "&" ;
terminator PostfixIncr "" ;
terminator PrimaryPostfix "" ;
separator RegenBranch "|" ;
terminator RegenToken "" ;
terminator RegenTokenNoOr "" ;
separator nonempty ExprNamedParamNonEmptyList "," ;
terminator ADTBodyItem "" ;
terminator StructBodyItem "" ;

-- Tokens

-- NOTE: Currently we are using BNFC pre-defined chars and strings literals
-- there may be differences between these and original Sketch lang definitions
-- refer to ANTLR2 grammar for original definitions
token Id (((letter|'_') (letter|digit|'_')*)|
    {"op.+"}| {"op.-"}| {"op.*"}| {"op./"}| {"op.%"}| {"op.="}| {"op.<"}) ;
token Number (digit+ ('.' digit+)? (('e'|'E') ('+'|'-')? digit+)? 'i'? ) ;
token HQuan {"0x"} ( digit | ["abcdefABCDEF"] )+ ;